/**
 * IMPROVED processChatbotQuery - Much smarter query handling
 * Replace your existing function with this
 */
function processChatbotQuery(query) {
  const sheet = getSheet(SHEETS.EXPENSES);
  if (!sheet) return { success: false, message: 'No expense data found' };

  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  const rows = data.slice(1);

  // Parse expenses
  const expenses = rows.map(row => {
    const obj = {};
    headers.forEach((header, idx) => {
      obj[header] = row[idx];
    });
    return obj;
  });

  const lowerQuery = query.toLowerCase();
  const now = new Date();
  const currentMonth = now.getMonth();
  const currentYear = now.getFullYear();

  // Filter current month expenses
  const currentMonthExpenses = expenses.filter(e => {
    const expenseDate = new Date(e.Date);
    return expenseDate.getMonth() === currentMonth && 
           expenseDate.getFullYear() === currentYear;
  });

  // ===========================================
  // 1. CATEGORY VS 3-MONTH AVERAGE COMPARISON
  // ===========================================
  if ((lowerQuery.includes('category') || lowerQuery.includes('categories')) && 
      (lowerQuery.includes('higher') || lowerQuery.includes('above') || lowerQuery.includes('exceed')) && 
      (lowerQuery.includes('average') || lowerQuery.includes('avg'))) {
    
    // Current month category totals
    const currentCategoryTotals = {};
    currentMonthExpenses.forEach(e => {
      const cat = e.Category || 'Uncategorized';
      currentCategoryTotals[cat] = (currentCategoryTotals[cat] || 0) + parseFloat(e.Amount || 0);
    });

    // Last 3 months category totals
    const last3MonthsCategoryData = {};
    for (let i = 1; i <= 3; i++) {
      const targetMonth = new Date(currentYear, currentMonth - i, 1);
      const monthExpenses = expenses.filter(e => {
        const d = new Date(e.Date);
        return d.getMonth() === targetMonth.getMonth() && 
               d.getFullYear() === targetMonth.getFullYear();
      });
      
      monthExpenses.forEach(e => {
        const cat = e.Category || 'Uncategorized';
        if (!last3MonthsCategoryData[cat]) {
          last3MonthsCategoryData[cat] = [];
        }
        last3MonthsCategoryData[cat].push(parseFloat(e.Amount || 0));
      });
    }

    // Calculate 3-month averages per category
    const categoryAverages = {};
    Object.keys(last3MonthsCategoryData).forEach(cat => {
      const amounts = last3MonthsCategoryData[cat];
      const monthTotals = {};
      
      // Group by month
      for (let i = 1; i <= 3; i++) {
        const targetMonth = new Date(currentYear, currentMonth - i, 1);
        const monthKey = `${targetMonth.getMonth()}-${targetMonth.getFullYear()}`;
        monthTotals[monthKey] = 0;
      }
      
      // Sum amounts per month for this category
      for (let i = 1; i <= 3; i++) {
        const targetMonth = new Date(currentYear, currentMonth - i, 1);
        const monthKey = `${targetMonth.getMonth()}-${targetMonth.getFullYear()}`;
        const monthExpenses = expenses.filter(e => {
          const d = new Date(e.Date);
          return d.getMonth() === targetMonth.getMonth() && 
                 d.getFullYear() === targetMonth.getFullYear() &&
                 (e.Category || 'Uncategorized') === cat;
        });
        monthTotals[monthKey] = monthExpenses.reduce((sum, e) => sum + parseFloat(e.Amount || 0), 0);
      }
      
      const total = Object.values(monthTotals).reduce((sum, val) => sum + val, 0);
      categoryAverages[cat] = total / 3;
    });

    // Compare current vs average
    const categoriesAboveAverage = [];
    Object.keys(currentCategoryTotals).forEach(cat => {
      const currentTotal = currentCategoryTotals[cat];
      const avg = categoryAverages[cat] || 0;
      
      if (avg > 0 && currentTotal > avg) {
        const percentHigher = ((currentTotal - avg) / avg) * 100;
        categoriesAboveAverage.push({
          category: cat,
          current: currentTotal,
          average: avg,
          percentHigher: percentHigher
        });
      }
    });

    // Build response
    if (categoriesAboveAverage.length === 0) {
      return {
        success: true,
        response: `‚úÖ Good news! No categories are above their 3-month average this month. Your spending is well-balanced across all categories.`
      };
    }

    categoriesAboveAverage.sort((a, b) => b.percentHigher - a.percentHigher);
    const topCategories = categoriesAboveAverage.slice(0, 5);
    
    let response = `üìä Yes, ${categoriesAboveAverage.length} ${categoriesAboveAverage.length === 1 ? 'category is' : 'categories are'} above their 3-month average:\n\n`;
    
    topCategories.forEach((cat, idx) => {
      const icon = idx === 0 ? 'üî¥' : (idx === 1 ? 'üü†' : 'üü°');
      response += `${icon} ${cat.category}: ‚Çπ${cat.current.toFixed(2)}\n`;
      response += `   (Avg: ‚Çπ${cat.average.toFixed(2)}, +${cat.percentHigher.toFixed(1)}%)\n\n`;
    });
    
    if (categoriesAboveAverage.length > 5) {
      response += `...and ${categoriesAboveAverage.length - 5} more categories above average.`;
    }
    
    return { success: true, response: response.trim() };
  }

  // ===========================================
  // 2. SPENDING TREND ANALYSIS
  // ===========================================
  if (lowerQuery.includes('trend') || lowerQuery.includes('pattern') || lowerQuery.includes('spending this month')) {
    const totalSpent = currentMonthExpenses.reduce((sum, e) => sum + parseFloat(e.Amount || 0), 0);
    const avgDaily = totalSpent / now.getDate();

    // Category breakdown
    const categoryMap = {};
    currentMonthExpenses.forEach(e => {
      const cat = e.Category || 'Uncategorized';
      categoryMap[cat] = (categoryMap[cat] || 0) + parseFloat(e.Amount || 0);
    });
    
    const sortedCategories = Object.entries(categoryMap)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 3);

    // Last month comparison
    const lastMonth = new Date(currentYear, currentMonth - 1, 1);
    const lastMonthExpenses = expenses.filter(e => {
      const d = new Date(e.Date);
      return d.getMonth() === lastMonth.getMonth() && 
             d.getFullYear() === lastMonth.getFullYear();
    });
    const lastMonthTotal = lastMonthExpenses.reduce((sum, e) => sum + parseFloat(e.Amount || 0), 0);
    
    let trendText = '';
    if (lastMonthTotal > 0) {
      const change = ((totalSpent - lastMonthTotal) / lastMonthTotal) * 100;
      const changeIcon = change > 0 ? 'üìà' : 'üìâ';
      trendText = `\n\n${changeIcon} Compared to last month: ${change > 0 ? '+' : ''}${change.toFixed(1)}% (‚Çπ${(totalSpent - lastMonthTotal).toFixed(2)})`;
    }

    const response = `üí∞ This month you've spent ‚Çπ${totalSpent.toFixed(2)} across ${currentMonthExpenses.length} transactions.\n\n` +
                    `üìä Daily average: ‚Çπ${avgDaily.toFixed(2)}\n\n` +
                    `üèÜ Top categories:\n` +
                    sortedCategories.map(([cat, amt]) => `‚Ä¢ ${cat}: ‚Çπ${amt.toFixed(2)}`).join('\n') +
                    trendText;

    return { success: true, response };
  }

  // ===========================================
  // 3. TOP SPENDING CATEGORY
  // ===========================================
  if ((lowerQuery.includes('which') || lowerQuery.includes('what')) && 
      (lowerQuery.includes('category') || lowerQuery.includes('categories')) && 
      (lowerQuery.includes('most') || lowerQuery.includes('highest') || lowerQuery.includes('top'))) {
    
    const categoryMap = {};
    currentMonthExpenses.forEach(e => {
      const cat = e.Category || 'Uncategorized';
      categoryMap[cat] = (categoryMap[cat] || 0) + parseFloat(e.Amount || 0);
    });

    const sorted = Object.entries(categoryMap).sort((a, b) => b[1] - a[1]);
    const totalSpent = currentMonthExpenses.reduce((sum, e) => sum + parseFloat(e.Amount || 0), 0);
    
    let response = `üèÜ Your top spending categories this month:\n\n`;
    sorted.slice(0, 5).forEach(([cat, amt], idx) => {
      const percentage = ((amt / totalSpent) * 100).toFixed(1);
      const icon = idx === 0 ? 'ü•á' : (idx === 1 ? 'ü•à' : (idx === 2 ? 'ü•â' : '‚Ä¢'));
      response += `${icon} ${cat}: ‚Çπ${amt.toFixed(2)} (${percentage}%)\n`;
    });

    return { success: true, response };
  }

  // ===========================================
  // 4. TOTAL SPENDING
  // ===========================================
  if (lowerQuery.includes('total') || lowerQuery.includes('how much') || lowerQuery.includes('spent')) {
    const totalSpent = currentMonthExpenses.reduce((sum, e) => sum + parseFloat(e.Amount || 0), 0);
    const numCategories = new Set(currentMonthExpenses.map(e => e.Category)).size;
    const avgDaily = totalSpent / now.getDate();

    return {
      success: true,
      response: `üí∞ This month you've spent ‚Çπ${totalSpent.toFixed(2)} across ${numCategories} categories and ${currentMonthExpenses.length} transactions.\n\nüìä Daily average: ‚Çπ${avgDaily.toFixed(2)}`
    };
  }

  // ===========================================
  // 5. WEEK COMPARISON
  // ===========================================
  if (lowerQuery.includes('week') && (lowerQuery.includes('compare') || lowerQuery.includes('last') || lowerQuery.includes('this'))) {
    const weekAgo = new Date(now);
    weekAgo.setDate(now.getDate() - 7);
    
    const thisWeek = currentMonthExpenses.filter(e => {
      const d = new Date(e.Date);
      return d >= weekAgo && d <= now;
    });
    const thisWeekTotal = thisWeek.reduce((sum, e) => sum + parseFloat(e.Amount || 0), 0);

    const twoWeeksAgo = new Date(now);
    twoWeeksAgo.setDate(now.getDate() - 14);
    
    const lastWeek = currentMonthExpenses.filter(e => {
      const d = new Date(e.Date);
      return d >= twoWeeksAgo && d < weekAgo;
    });
    const lastWeekTotal = lastWeek.reduce((sum, e) => sum + parseFloat(e.Amount || 0), 0);

    if (lastWeekTotal === 0) {
      return {
        success: true,
        response: `üìä This week's spending: ‚Çπ${thisWeekTotal.toFixed(2)} (${thisWeek.length} transactions)\n\nNo data available for last week to compare.`
      };
    }

    const change = ((thisWeekTotal - lastWeekTotal) / lastWeekTotal) * 100;
    const changeIcon = change > 0 ? 'üìà' : 'üìâ';
    const changeText = change > 0 ? 'higher' : 'lower';

    return {
      success: true,
      response: `${changeIcon} This week: ‚Çπ${thisWeekTotal.toFixed(2)} (${thisWeek.length} transactions)\n` +
               `Last week: ‚Çπ${lastWeekTotal.toFixed(2)} (${lastWeek.length} transactions)\n\n` +
               `Change: ${Math.abs(change).toFixed(1)}% ${changeText} (‚Çπ${Math.abs(thisWeekTotal - lastWeekTotal).toFixed(2)})`
    };
  }

  // ===========================================
  // 6. IMPULSE PURCHASES
  // ===========================================
  if (lowerQuery.includes('impulse')) {
    const impulseExpenses = currentMonthExpenses.filter(e => {
      const labels = (e.Labels || '').toLowerCase();
      return labels.includes('impulse');
    });
    
    const impulseTotal = impulseExpenses.reduce((sum, e) => sum + parseFloat(e.Amount || 0), 0);
    const totalSpent = currentMonthExpenses.reduce((sum, e) => sum + parseFloat(e.Amount || 0), 0);
    const percentage = totalSpent > 0 ? ((impulseTotal / totalSpent) * 100).toFixed(1) : 0;

    if (impulseExpenses.length === 0) {
      return {
        success: true,
        response: `‚úÖ Great job! No impulse purchases detected this month.`
      };
    }

    // Top impulse items
    const impulseByCategory = {};
    impulseExpenses.forEach(e => {
      const cat = e.Category || 'Uncategorized';
      impulseByCategory[cat] = (impulseByCategory[cat] || 0) + parseFloat(e.Amount || 0);
    });
    
    const topImpulse = Object.entries(impulseByCategory)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 3);

    let response = `üõçÔ∏è Impulse purchases: ‚Çπ${impulseTotal.toFixed(2)} (${percentage}% of total)\n\n`;
    response += `${impulseExpenses.length} impulse transactions found:\n`;
    topImpulse.forEach(([cat, amt]) => {
      response += `‚Ä¢ ${cat}: ‚Çπ${amt.toFixed(2)}\n`;
    });

    if (percentage > 15) {
      response += `\n‚ö†Ô∏è This is ${percentage}% of your spending. Consider setting a weekly impulse budget of ‚Çπ${(impulseTotal / 4).toFixed(2)} to reduce by 50%.`;
    } else {
      response += `\n‚úÖ Good control over impulse spending!`;
    }

    return { success: true, response };
  }

  // ===========================================
  // 7. UNUSUAL PATTERNS / ANOMALIES
  // ===========================================
  if (lowerQuery.includes('unusual') || lowerQuery.includes('anomaly') || lowerQuery.includes('strange') || lowerQuery.includes('weird')) {
    const insights = [];
    const totalSpent = currentMonthExpenses.reduce((sum, e) => sum + parseFloat(e.Amount || 0), 0);
    const avgDaily = totalSpent / now.getDate();

    // Check today's spending
    const todayExpenses = currentMonthExpenses.filter(e => {
      const d = new Date(e.Date);
      return d.toDateString() === now.toDateString();
    });
    const todayTotal = todayExpenses.reduce((sum, e) => sum + parseFloat(e.Amount || 0), 0);
    
    if (todayTotal > avgDaily * 2) {
      insights.push(`üî¥ Today's spending (‚Çπ${todayTotal.toFixed(2)}) is ${((todayTotal / avgDaily - 1) * 100).toFixed(0)}% above daily average`);
    }

    // Check spending bursts
    const timeMap = {};
    currentMonthExpenses.forEach(e => {
      if (e.Timestamp) {
        const hour = new Date(e.Timestamp).getHours();
        const dateKey = new Date(e.Timestamp).toDateString();
        const key = `${dateKey}-${hour}`;
        timeMap[key] = (timeMap[key] || 0) + 1;
      }
    });
    
    const bursts = Object.entries(timeMap).filter(([_, count]) => count >= 3);
    if (bursts.length > 0) {
      insights.push(`‚ö° Spending burst detected: ${bursts[0][1]} transactions in one hour`);
    }

    // Check vendor frequency
    const vendorMap = {};
    currentMonthExpenses.forEach(e => {
      const vendor = e['Shop/Site/Person name'];
      if (vendor) {
        vendorMap[vendor] = (vendorMap[vendor] || 0) + 1;
      }
    });
    
    const frequentVendors = Object.entries(vendorMap).filter(([_, count]) => count >= 5);
    if (frequentVendors.length > 0) {
      const top = frequentVendors.sort((a, b) => b[1] - a[1])[0];
      insights.push(`üè™ High frequency: ${top[1]} transactions at ${top[0]}`);
    }

    if (insights.length === 0) {
      return {
        success: true,
        response: `‚úÖ No unusual spending patterns detected this month. Your spending behavior looks consistent!`
      };
    }

    return {
      success: true,
      response: `üîç Unusual patterns detected:\n\n` + insights.join('\n\n')
    };
  }

  // ===========================================
  // 8. DEFAULT / FALLBACK
  // ===========================================
  const totalSpent = currentMonthExpenses.reduce((sum, e) => sum + parseFloat(e.Amount || 0), 0);
  const categoryMap = {};
  currentMonthExpenses.forEach(e => {
    const cat = e.Category || 'Uncategorized';
    categoryMap[cat] = (categoryMap[cat] || 0) + parseFloat(e.Amount || 0);
  });
  const topCategory = Object.entries(categoryMap).sort((a, b) => b[1] - a[1])[0];

  return {
    success: true,
    response: `üí° This month: ‚Çπ${totalSpent.toFixed(2)} spent across ${currentMonthExpenses.length} transactions.\n\n` +
             `üèÜ Top category: ${topCategory[0]} (‚Çπ${topCategory[1].toFixed(2)})\n\n` +
             `Try asking:\n‚Ä¢ "Which category did I spend most on?"\n‚Ä¢ "Compare this week with last week"\n‚Ä¢ "Show my impulse purchases"\n‚Ä¢ "Are any categories above average?"`
  };
}